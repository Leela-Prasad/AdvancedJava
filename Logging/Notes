There are 2 Objects
1. Logger
2. Appenders

Logger object will generate the Logging events
and these logging events are generated by below statements
log.debug(“”);
log.info(“”);

Logging Events contains below information
Level
Message that needs to be logged
Source i.e., class name where the event is generated.
Time
Other information like exception trace etc.

Appenders will catch these log events and publish it to destination like console or file or database etc.

Appenders are mentioned in a configuration file and can be changed at runtime.

*** If there is no Appender for a specific log event then that log will be lost.

For a log event there can be multiple appenders 
e.g.: a log event can be written to console and file at the same time.

Appenders publish the log events to the destination based on 2 factors.
1. source of the event i.e., which class in our application generated the event.
2. Level of severity of event.

Logging Levels
FATAL
ERROR
WARN
INFO
DEBUG
TRACE


** If log4j configuration file is not provided then the default behaviour is logging ONLY ERRORS TO CONSOLE.
ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.

Log4j file
<Configuration status="INFO">
<Appenders>
</Appenders>
<Loggers>
<Logger name="LoggingExample" level="INFO">
  <AppenderRef ref="STDOUT"/>
</Logger>
<Root level="INFO">
  <AppenderRef ref="file" level=“INFO”/>
  <AppenderRef ref="STDOUT" level="ERROR"/>
</Root>
</Loggers>
</Configuration>

Here the status attribute in configuration node sets the Global Logger level, if any appender not defined the level then this global Logging Level will be taken.

*** If you don’t mention the status attribute the then default Global Logger Level will be ERROR.

In Logger node we should define one Root Logger and we can have 0 to many different loggers in the logger node.

Here Root logger also defines a global log level INFO which can be overridden in appender ref nodes.


If you see there is a logger which will log events from LoggingExample but log events from this class will be printed twice for Error and Fatal.
This is because these Error and Fatal events are received by both Logger and Root Logger,so to suppress the log events reaching to root logger we need to turn off additivity. i.e., additivity="false"
<Logger name="LoggingExample" level="INFO" additivity="false">
  <AppenderRef ref="STDOUT"/>
</Logger>

(or)
don’t mention appender ref so that root logger will take care of logging those events.
<Logger name="LoggingExample" level="INFO" />

Logging Facades:
When we have common libraries or frameworks like spring, hibernate which will used across projects then the question is which logging framework this common libraries or frameworks should use
suppose log4j is most common and if they log4j then applications which uses JUL as their logging framework will fail, so address these issues we have Logging Facades which will redirect to respective frameworks at runtime.
These facades will check whether we have log4j jar in the class path or not if it there then the logging facades will work with log4j, if it is not there then the logging facades will work with JUL.

Below are the logging facades available:
1. apache commons logging.
2. slf4j
3. JBOSS Logging.


-Djava.util.logging.config.file=“${project_loc}/logging.properties”